<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>KPHL Snow Forecast Comparison</title>
  <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Barlow+Condensed:wght@300;400;600;700&display=swap" rel="stylesheet" />
  <style>
    :root {
      --bg: #0a0e14;
      --panel: #0f1520;
      --border: #1e2d45;
      --accent: #2a9fd6;
      --accent2: #00e5ff;
      --warn: #f0b429;
      --dim: #3a4a5c;
      --text: #cdd6e0;
      --mono: 'Share Tech Mono', monospace;
      --sans: 'Barlow Condensed', sans-serif;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { background: var(--bg); color: var(--text); font-family: var(--sans); min-height: 100vh; padding-bottom: 60px; }

    header {
      background: var(--panel);
      border-bottom: 1px solid var(--border);
      padding: 18px 28px 14px;
      display: flex; align-items: flex-end; gap: 20px; flex-wrap: wrap;
    }
    header h1 { font-size: 2rem; font-weight: 700; letter-spacing: .12em; text-transform: uppercase; color: var(--accent2); line-height: 1; }
    header h1 span { color: var(--warn); }
    .header-sub { font-size: .85rem; color: var(--dim); font-family: var(--mono); letter-spacing: .05em; margin-bottom: 2px; }
    .header-meta { margin-left: auto; text-align: right; }
    .header-meta .ts { font-family: var(--mono); font-size: .78rem; color: var(--dim); }

    .controls {
      display: flex; gap: 12px; align-items: center;
      padding: 14px 28px; background: #0c1119;
      border-bottom: 1px solid var(--border); flex-wrap: wrap;
    }
    .controls label { font-size: .8rem; text-transform: uppercase; letter-spacing: .1em; color: var(--dim); }
    select, input[type="date"], input[type="number"] {
      background: var(--panel); border: 1px solid var(--border); color: var(--text);
      font-family: var(--mono); font-size: .82rem; padding: 6px 10px; border-radius: 3px; outline: none;
    }
    select:focus, input:focus { border-color: var(--accent); }
    .btn {
      padding: 7px 18px; background: var(--accent); color: #000; border: none;
      border-radius: 3px; font-family: var(--sans); font-weight: 700; font-size: .85rem;
      letter-spacing: .08em; text-transform: uppercase; cursor: pointer; transition: background .15s;
    }
    .btn:hover { background: var(--accent2); }
    .btn-ghost { background: transparent; border: 1px solid var(--border); color: var(--dim); }
    .btn-ghost:hover { border-color: var(--accent); color: var(--accent); background: transparent; }

    #statusBar {
      padding: 8px 28px; font-family: var(--mono); font-size: .75rem;
      min-height: 32px; display: flex; gap: 14px; align-items: center; flex-wrap: wrap;
      border-bottom: 1px solid var(--border);
    }
    .status-item { display: flex; align-items: center; gap: 5px; }
    .dot { width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0; }
    .dot-ok { background: #4caf50; }
    .dot-loading { background: var(--warn); animation: pulse 1s infinite; }
    .dot-err { background: #ef5350; }
    .dot-manual { background: var(--dim); }
    @keyframes pulse { 0%,100%{opacity:1}50%{opacity:.3} }

    .table-wrap { padding: 20px 28px; overflow-x: auto; }

    table { width: 100%; border-collapse: collapse; font-size: .88rem; min-width: 760px; }

    thead th {
      padding: 7px 9px; text-align: center;
      font-family: var(--mono); font-size: .7rem; letter-spacing: .06em;
      text-transform: uppercase; color: var(--dim);
      border-bottom: 2px solid var(--border); white-space: nowrap;
    }
    thead th.th-source { text-align: left; color: var(--text); }
    thead .th-group {
      background: #0c1119; color: var(--accent); font-size: .67rem;
      padding: 4px 9px; border-bottom: 1px solid var(--border); letter-spacing: .1em;
    }

    /* divider rows between model groups */
    tr.group-divider td {
      padding: 3px 0; background: #0c1119;
      font-family: var(--mono); font-size: .65rem; letter-spacing: .12em;
      text-transform: uppercase; color: var(--accent); padding-left: 10px;
      border-top: 1px solid var(--border); border-bottom: 1px solid var(--border);
    }

    tbody tr { border-bottom: 1px solid #111c28; transition: background .1s; }
    tbody tr:hover:not(.group-divider) { background: rgba(42,159,214,.06); }
    tbody tr.nws-row { background: rgba(0,229,255,.04); }
    tbody tr.nws-row:hover { background: rgba(0,229,255,.09); }

    td { padding: 9px 9px; text-align: center; font-family: var(--mono); font-size: .82rem; white-space: nowrap; }
    td.td-source { text-align: left; font-family: var(--sans); font-weight: 600; font-size: .9rem; letter-spacing: .04em; }
    td.td-run { font-size: .71rem; color: var(--dim); }
    td.td-total { font-weight: 700; color: var(--accent2); border-left: 1px solid var(--border); }

    /* snow heat map */
    .snow-null  { color: var(--dim); }
    .snow-0     { color: #4a5a6a; }
    .snow-t     { color: #6baed6; font-size: .72rem; }
    .snow-low   { color: #9ecae1; }
    .snow-mid   { color: #4292c6; }
    .snow-high  { color: #08519c; background: #c8e6ff22; border-radius: 3px; }
    .snow-huge  { color: #fff; background: #08519c66; border-radius: 3px; }

    /* badges */
    .badge {
      display: inline-block; padding: 1px 5px; border-radius: 2px;
      font-size: .68rem; font-family: var(--mono); margin-left: 5px; vertical-align: middle;
    }
    .badge-nws   { background:#00e5ff18;color:var(--accent2);border:1px solid #00e5ff33; }
    .badge-nbm   { background:#00e5ff0c;color:#80deea;border:1px solid #00e5ff22; }
    .badge-gfs   { background:#4caf5018;color:#81c784;border:1px solid #4caf5033; }
    .badge-gefs  { background:#4caf500c;color:#a5d6a7;border:1px solid #4caf5022; }
    .badge-ecmwf { background:#9c27b018;color:#ce93d8;border:1px solid #9c27b033; }
    .badge-hrrr  { background:#ff980018;color:#ffb74d;border:1px solid #ff980033; }
    .badge-nam   { background:#e91e6318;color:#f48fb1;border:1px solid #e91e6333; }
    .badge-gem   { background:#ff572218;color:#ff8a65;border:1px solid #ff572233; }
    .badge-user  { background:#1e2d45;color:var(--dim);border:1px solid #1e2d45; }

    td[contenteditable="true"] { outline: none; cursor: text; }
    td[contenteditable="true"]:focus { background: rgba(42,159,214,.12); border-bottom: 1px solid var(--accent); }

    .legend {
      display: flex; gap: 18px; align-items: center;
      padding: 0 28px 14px; flex-wrap: wrap;
      font-size: .74rem; color: var(--dim); font-family: var(--mono);
    }
    .legend span { display: flex; align-items: center; gap: 5px; }

    .notes { padding: 0 28px; font-size: .76rem; color: var(--dim); font-family: var(--mono); line-height: 1.8; }
    .notes a { color: var(--accent); text-decoration: none; }
    .notes a:hover { text-decoration: underline; }

    #overlay {
      position: fixed; inset: 0; background: rgba(10,14,20,.88);
      display: none; align-items: center; justify-content: center; z-index: 100;
    }
    .spinner-box { font-family: var(--mono); font-size: .85rem; color: var(--accent2); text-align: center; }
    .spinner-box .spin { font-size: 2.2rem; animation: rotateSpin 1.2s linear infinite; display: block; margin-bottom: 12px; }
    @keyframes rotateSpin { to { transform: rotate(360deg); } }

    .empty-msg { text-align: center; padding: 40px; color: var(--dim); font-family: var(--mono); font-size: .82rem; }

    @media(max-width:600px){
      header,.controls,.table-wrap,.legend,.notes{ padding-left:14px;padding-right:14px; }
    }
  </style>
</head>
<body>

<div id="overlay" style="display:none">
  <div class="spinner-box">
    <span class="spin">❄</span>
    <div id="overlayMsg">Fetching forecast data…</div>
  </div>
</div>

<header>
  <div>
    <h1>K<span>PHL</span> Snow Forecast</h1>
    <div class="header-sub">Philadelphia Intl · 39.8729°N 75.2437°W · Elev 36 ft</div>
  </div>
  <div class="header-meta">
    <div class="ts" id="clockDisplay">—</div>
    <div class="ts" style="color:var(--text);margin-top:2px">Model Comparison Dashboard</div>
  </div>
</header>

<div class="controls">
  <label>Event Start (UTC)</label>
  <input type="date" id="startDate" />
  <label>6-hr Periods</label>
  <input type="number" id="numPeriods" value="8" min="2" max="24" style="width:58px" />
  <button class="btn" onclick="fetchAll()">⟳ Refresh Models</button>
  <button class="btn btn-ghost" onclick="clearManual()">Clear Manual</button>
  <button class="btn btn-ghost" onclick="exportCSV()">↓ CSV</button>
</div>

<div id="statusBar"></div>

<div class="table-wrap">
  <table id="snowTable">
    <thead id="tableHead"></thead>
    <tbody id="tableBody">
      <tr><td colspan="20" class="empty-msg">← Set a start date and click Refresh Models</td></tr>
    </tbody>
  </table>
</div>

<div class="legend">
  <span><span class="dot dot-ok"></span>Live data</span>
  <span><span class="dot dot-err"></span>Fetch error</span>
  <span><span class="dot dot-manual"></span>Manual</span>
  <span style="margin-left:6px;color:var(--text)">Snow (in):</span>
  <span class="snow-0">0.0</span>
  <span class="snow-t">T</span>
  <span class="snow-low">0.1–1.9</span>
  <span class="snow-mid">2–4.9</span>
  <span class="snow-high">5–9.9</span>
  <span class="snow-huge">10+</span>
</div>

<div class="notes">
  <strong style="color:var(--text)">Data sources:</strong>
  NWS Official &amp; NBM via <a href="https://api.weather.gov" target="_blank">api.weather.gov</a> gridded snowfallAmount (mm→in) ·
  GFS, HRRR, NAM, GEFS, GEM via <a href="https://open-meteo.com" target="_blank">Open-Meteo</a> (free, no key) ·
  ECMWF via Open-Meteo ECMWF endpoint<br/>
  All snowfall values aggregated from hourly data into 6-hr period totals · Click any cell to edit manually · 
  NWS/NBM gridded data uses ISO 8601 duration intervals · HRRR limited to ~48 hr forecast range
</div>

<script>
// ═══════════════════════════════════════════════════════════
// CONFIG
// ═══════════════════════════════════════════════════════════
const LAT = 39.8729, LON = -75.2437;
const MM_TO_IN = 0.0393701;   // NWS gridded snowfall is in mm (Wmounit:mm)
const CM_TO_IN = 0.393701;    // Open-Meteo snowfall is in cm

// Source definitions — grouped for display
const SOURCES = [
  // ── Official ──────────────────────────────────────────────
  { id:'nws',   label:'NWS Official',   badge:'nws',   group:'Official',  fetch: fetchNWSGridded },
  { id:'nbm',   label:'NBM Conus',      badge:'nbm',   group:'Official',  fetch: (s,n)=>fetchOpenMeteo('nbm_conus',s,n,true) },
  // ── Global ────────────────────────────────────────────────
  { id:'gfs',   label:'GFS Seamless',   badge:'gfs',   group:'Global',    fetch: (s,n)=>fetchOpenMeteo('gfs_seamless',s,n,true) },
  { id:'gefs',  label:'GEFS Mean',      badge:'gefs',  group:'Global',    fetch: fetchGEFS },
  { id:'ecmwf', label:'ECMWF IFS',      badge:'ecmwf', group:'Global',    fetch: fetchECMWF },
  { id:'gem',   label:'GEM (Canadian)', badge:'gem',   group:'Global',    fetch: (s,n)=>fetchOpenMeteo('gem_seamless',s,n,true) },
  // ── Mesoscale ─────────────────────────────────────────────
  { id:'hrrr',  label:'HRRR',           badge:'hrrr',  group:'Mesoscale', fetch: (s,n)=>fetchOpenMeteo('hrrr_conus',s,n,true) },
  { id:'nam',   label:'NAM Conus',      badge:'nam',   group:'Mesoscale', fetch: (s,n)=>fetchOpenMeteo('nam_conus',s,n,true) },
];

let state = { startDate:null, numPeriods:8, data:{}, status:{} };

// ═══════════════════════════════════════════════════════════
// INIT
// ═══════════════════════════════════════════════════════════
window.addEventListener('DOMContentLoaded', ()=>{
  const today = new Date();
  document.getElementById('startDate').value = today.toISOString().slice(0,10);
  setInterval(updateClock, 1000); updateClock();
  renderStatusBar();
});

function updateClock(){
  const u = new Date().toUTCString();
  document.getElementById('clockDisplay').textContent = u.replace(/^.*?, /,'').replace(' GMT','  UTC');
}

// ═══════════════════════════════════════════════════════════
// ORCHESTRATOR
// ═══════════════════════════════════════════════════════════
async function fetchAll(){
  const dateVal = document.getElementById('startDate').value;
  const numP    = Math.max(2, Math.min(24, parseInt(document.getElementById('numPeriods').value)||8));
  if(!dateVal){ alert('Please select a start date.'); return; }

  state.startDate  = new Date(dateVal+'T00:00:00Z');
  state.numPeriods = numP;
  state.data   = {};
  state.status = {};
  SOURCES.forEach(s=>{ state.status[s.id]='loading'; });
  renderStatusBar(); renderTable();
  showOverlay('Fetching forecast data from APIs…');

  await Promise.allSettled(SOURCES.map(async src=>{
    try {
      state.data[src.id]   = await src.fetch(state.startDate, numP);
      state.status[src.id] = 'ok';
    } catch(e){
      console.warn(src.id, e.message);
      state.data[src.id]   = { runTime:null, periods:Array(numP).fill(null), error: e.message };
      state.status[src.id] = 'error';
    }
  }));

  hideOverlay(); renderStatusBar(); renderTable();
}

// ═══════════════════════════════════════════════════════════
// NWS GRIDDED  (forecastGridData → snowfallAmount)
// ═══════════════════════════════════════════════════════════
async function fetchNWSGridded(startDate, numP){
  const H = {'User-Agent':'KPHL-Snow-Dashboard/2.0 github.com/howpomp'};

  // 1) points → grid URL
  const pt = await fetchJSON(`https://api.weather.gov/points/${LAT},${LON}`, H);
  const gridUrl = pt.properties.forecastGridData;
  const updateTime = pt.properties.generatedAt || pt.properties.updateTime || null;

  // 2) gridded data
  const gd = await fetchJSON(gridUrl, H);
  const props = gd.properties;
  const runTime = props.updateTime ? fmtRunTime(new Date(props.updateTime)) : 'NWS Current';

  // snowfallAmount is in Wmounit:mm, values array with ISO 8601 duration validTime
  const snowVals = props.snowfallAmount ? props.snowfallAmount.values : [];
  // Also try snowfall (alternate key in some WFOs)
  const altVals  = (!snowVals.length && props.snowfall) ? props.snowfall.values : [];
  const useVals  = snowVals.length ? snowVals : altVals;

  // Build hourly lookup map: utc-hour-string → mm
  const hourMap = {};
  useVals.forEach(({validTime, value})=>{
    if(value == null) return;
    // validTime: "2026-02-21T06:00:00+00:00/PT1H" or "/PT3H" etc.
    const [timeStr, durStr] = validTime.split('/');
    const baseTime = new Date(timeStr);
    const hrs = parsePTHours(durStr);
    for(let h=0; h<hrs; h++){
      const key = new Date(baseTime.getTime() + h*3600000).toISOString().slice(0,13);
      hourMap[key] = value; // mm
    }
  });

  const periods = buildPeriods(startDate, numP, hourMap, MM_TO_IN);
  return { runTime, periods };
}

// ═══════════════════════════════════════════════════════════
// OPEN-METEO GENERIC  (GFS, HRRR, NAM, NBM, GEM)
// ═══════════════════════════════════════════════════════════
async function fetchOpenMeteo(model, startDate, numP, isCm=true){
  const startStr = startDate.toISOString().slice(0,10);
  const endDate  = new Date(startDate.getTime() + numP*6*3600000 + 86400000);
  const endStr   = endDate.toISOString().slice(0,10);

  // HRRR only has ~48 hr forecast, clamp
  const forecastDays = model==='hrrr_conus' ? 2 : 7;

  const url = `https://api.open-meteo.com/v1/forecast`
    + `?latitude=${LAT}&longitude=${LON}`
    + `&hourly=snowfall`
    + `&models=${model}`
    + `&start_date=${startStr}&end_date=${endStr}`
    + `&timezone=UTC`
    + `&forecast_days=${forecastDays}`;

  const json = await fetchJSON(url);
  const times = json.hourly.time;
  const snow  = json.hourly.snowfall;  // cm by default

  // Build hourly map
  const hourMap = {};
  times.forEach((t,i)=>{ if(snow[i]!=null) hourMap[t.slice(0,13)] = snow[i]; });

  const factor = isCm ? CM_TO_IN : MM_TO_IN;
  const periods = buildPeriods(startDate, numP, hourMap, factor);

  // Approximate run time from first time entry
  const rt = times.length ? fmtRunTime(new Date(times[0])) : 'Latest run';
  return { runTime: rt, periods };
}

// ═══════════════════════════════════════════════════════════
// GEFS ENSEMBLE  (Open-Meteo ensemble endpoint)
// ═══════════════════════════════════════════════════════════
async function fetchGEFS(startDate, numP){
  const startStr = startDate.toISOString().slice(0,10);
  const endDate  = new Date(startDate.getTime() + numP*6*3600000 + 86400000);
  const endStr   = endDate.toISOString().slice(0,10);

  const url = `https://ensemble-api.open-meteo.com/v1/ensemble`
    + `?latitude=${LAT}&longitude=${LON}`
    + `&hourly=snowfall`
    + `&models=gfs_seamless`
    + `&start_date=${startStr}&end_date=${endStr}`
    + `&timezone=UTC`;

  const json = await fetchJSON(url);
  // Ensemble returns multiple members; average them
  const times = json.hourly.time;

  // Find all snowfall keys (snowfall_member01, etc.) or just snowfall
  const memberKeys = Object.keys(json.hourly).filter(k=>k.startsWith('snowfall'));
  if(!memberKeys.length) throw new Error('No GEFS snowfall data');

  const hourMap = {};
  times.forEach((t,i)=>{
    let sum=0, cnt=0;
    memberKeys.forEach(k=>{ const v=json.hourly[k][i]; if(v!=null){sum+=v;cnt++;} });
    if(cnt>0) hourMap[t.slice(0,13)] = sum/cnt;
  });

  const periods = buildPeriods(startDate, numP, hourMap, CM_TO_IN);
  return { runTime:`GEFS ${memberKeys.length}-mbr mean`, periods };
}

// ═══════════════════════════════════════════════════════════
// ECMWF  (separate Open-Meteo endpoint)
// ═══════════════════════════════════════════════════════════
async function fetchECMWF(startDate, numP){
  const startStr = startDate.toISOString().slice(0,10);
  const endDate  = new Date(startDate.getTime() + numP*6*3600000 + 86400000);
  const endStr   = endDate.toISOString().slice(0,10);

  const url = `https://api.open-meteo.com/v1/ecmwf`
    + `?latitude=${LAT}&longitude=${LON}`
    + `&hourly=snowfall`
    + `&start_date=${startStr}&end_date=${endStr}`
    + `&timezone=UTC`;

  const json = await fetchJSON(url);
  const times = json.hourly.time;
  const snow  = json.hourly.snowfall;

  const hourMap = {};
  times.forEach((t,i)=>{ if(snow[i]!=null) hourMap[t.slice(0,13)] = snow[i]; });

  const periods = buildPeriods(startDate, numP, hourMap, CM_TO_IN);
  return { runTime:'ECMWF IFS 9km', periods };
}

// ═══════════════════════════════════════════════════════════
// HELPERS
// ═══════════════════════════════════════════════════════════
async function fetchJSON(url, headers={}){
  const resp = await fetch(url, { headers: {'Accept':'application/json', ...headers} });
  if(!resp.ok) throw new Error(`HTTP ${resp.status} ${url.slice(0,60)}`);
  return resp.json();
}

function buildPeriods(startDate, numP, hourMap, factor){
  const periods = [];
  for(let p=0; p<numP; p++){
    const tStart = new Date(startDate.getTime() + p*6*3600000);
    let sum=0, hasAny=false;
    for(let h=0; h<6; h++){
      const key = new Date(tStart.getTime()+h*3600000).toISOString().slice(0,13);
      if(hourMap[key]!=null){ sum += hourMap[key]; hasAny=true; }
    }
    periods.push(hasAny ? parseFloat((sum*factor).toFixed(2)) : null);
  }
  return periods;
}

function parsePTHours(durStr){
  if(!durStr) return 1;
  const m = durStr.match(/PT(\d+)H/);
  return m ? parseInt(m[1]) : 1;
}

function fmtRunTime(d){
  if(!d||isNaN(d)) return '—';
  const mo  = d.toLocaleString('en-US',{month:'short',timeZone:'UTC'});
  const day = d.getUTCDate();
  const hr  = String(d.getUTCHours()).padStart(2,'0');
  return `${mo} ${day}  ${hr}z`;
}

function fmtPeriodHeader(d){
  const mo  = d.toLocaleString('en-US',{month:'short',timeZone:'UTC'});
  const day = d.getUTCDate();
  const h0  = String(d.getUTCHours()).padStart(2,'0');
  const h1  = String(d.getUTCHours()+6).padStart(2,'0');
  return `${mo} ${day}<br/>${h0}z–${h1}z`;
}

// ═══════════════════════════════════════════════════════════
// RENDER TABLE
// ═══════════════════════════════════════════════════════════
function renderTable(){
  if(!state.startDate) return;
  const numP = state.numPeriods;

  // ── thead ──
  const thead = document.getElementById('tableHead');
  thead.innerHTML = '';

  const gr = document.createElement('tr');
  gr.innerHTML = `<th class="th-group th-source" colspan="2">Source / Run</th>`
    + `<th class="th-group" colspan="${numP}">6-Hourly Snowfall Accumulation (inches)</th>`
    + `<th class="th-group">Storm Total</th>`;
  thead.appendChild(gr);

  const hr = document.createElement('tr');
  let hh = `<th class="th-source" style="text-align:left">Model</th><th>Run Init</th>`;
  for(let p=0;p<numP;p++){
    hh += `<th>${fmtPeriodHeader(new Date(state.startDate.getTime()+p*6*3600000))}</th>`;
  }
  hh += `<th>Total</th>`;
  hr.innerHTML = hh; thead.appendChild(hr);

  // ── tbody ──
  const tbody = document.getElementById('tableBody');
  tbody.innerHTML = '';

  let lastGroup = null;
  SOURCES.forEach(src=>{
    // Group divider
    if(src.group !== lastGroup){
      const dtr = document.createElement('tr');
      dtr.className = 'group-divider';
      dtr.innerHTML = `<td colspan="${numP+3}">${src.group} Models</td>`;
      tbody.appendChild(dtr);
      lastGroup = src.group;
    }

    const d   = state.data[src.id];
    const st  = state.status[src.id];
    const tr  = document.createElement('tr');
    if(src.id==='nws') tr.className='nws-row';

    const runLabel = d ? (d.runTime||'—') : (st==='loading'?'loading…':'—');
    let html = `<td class="td-source">${src.label}<span class="badge badge-${src.badge}">${src.badge.toUpperCase()}</span></td>`
              +`<td class="td-run">${runLabel}</td>`;

    let total=0, hasData=false;
    for(let p=0;p<numP;p++){
      const val = d ? d.periods[p] : null;
      const cls = snowClass(val);
      const fmt = formatSnow(val);
      html += `<td id="${src.id}-p${p}" class="${cls}" contenteditable="true"`
            + ` data-src="${src.id}" data-period="${p}"`
            + ` oninput="onCellEdit(this)"`
            + ` title="${new Date(state.startDate.getTime()+p*6*3600000).toUTCString()}">${fmt}</td>`;
      if(val!==null){ total+=val; hasData=true; }
    }

    const totFmt = hasData ? total.toFixed(1) : '—';
    html += `<td class="td-total ${snowClass(hasData?total:null)}" id="${src.id}-total">${totFmt}</td>`;
    tr.innerHTML = html;
    tbody.appendChild(tr);
  });

  // Manual row
  const mtr = document.createElement('tr');
  let mh = `<td class="td-source" style="color:var(--dim)">Manual Entry<span class="badge badge-user">USER</span></td>`
          +`<td class="td-run" style="color:var(--dim)">—</td>`;
  for(let p=0;p<numP;p++){
    const val = state.data['manual'] ? state.data['manual'].periods[p] : null;
    mh += `<td id="manual-p${p}" class="${snowClass(val)}" contenteditable="true"`
        + ` data-src="manual" data-period="${p}" oninput="onCellEdit(this)">${formatSnow(val)}</td>`;
  }
  const mTotal = state.data['manual']
    ? state.data['manual'].periods.filter(v=>v!==null).reduce((a,b)=>a+b,0)
    : null;
  mh += `<td class="td-total ${snowClass(mTotal)}" id="manual-total">${mTotal!==null?mTotal.toFixed(1):'—'}</td>`;
  mtr.innerHTML = mh;
  tbody.appendChild(mtr);
}

// ═══════════════════════════════════════════════════════════
// CELL EDIT
// ═══════════════════════════════════════════════════════════
function onCellEdit(td){
  const src    = td.dataset.src;
  const period = parseInt(td.dataset.period);
  const raw    = td.textContent.trim();

  if(!state.data[src]) state.data[src]={ runTime:null, periods:Array(state.numPeriods).fill(null) };

  let val = null;
  if(raw==='T'||raw==='t') val=0.005;
  else if(raw===''||raw==='—'||raw==='-') val=null;
  else { val=parseFloat(raw); if(isNaN(val)) val=null; }

  state.data[src].periods[period] = val;
  if(src!=='manual') state.status[src]='manual';
  td.className = snowClass(val);
  recalcTotal(src);
}

function recalcTotal(src){
  const d = state.data[src]; if(!d) return;
  let total=0, hasData=false;
  d.periods.forEach(v=>{ if(v!==null){ total+=v; hasData=true; } });
  const el = document.getElementById(`${src}-total`);
  if(el){ el.textContent=hasData?total.toFixed(1):'—'; el.className=`td-total ${snowClass(hasData?total:null)}`; }
}

// ═══════════════════════════════════════════════════════════
// STATUS BAR
// ═══════════════════════════════════════════════════════════
function renderStatusBar(){
  const bar = document.getElementById('statusBar');
  bar.innerHTML = SOURCES.map(src=>{
    const st  = state.status[src.id]||'manual';
    const cls = {ok:'dot-ok',loading:'dot-loading',error:'dot-err',manual:'dot-manual'}[st]||'dot-manual';
    const lbl = {ok:'Live',loading:'…',error:'Error',manual:'Manual'}[st]||'—';
    const extra = (st==='error' && state.data[src.id]?.error)
      ? ` title="${state.data[src.id].error}"` : '';
    return `<span class="status-item"${extra}><span class="dot ${cls}"></span>${src.label}: ${lbl}</span>`;
  }).join('');
}

// ═══════════════════════════════════════════════════════════
// UTILITIES
// ═══════════════════════════════════════════════════════════
function formatSnow(val){
  if(val===null||val===undefined) return '—';
  if(val===0.005||val===0.01) return 'T';
  if(val===0) return '0.0';
  return val.toFixed(1);
}

function snowClass(val){
  if(val===null||val===undefined) return 'snow-null';
  if(val<=0.004) return 'snow-0';
  if(val<=0.01)  return 'snow-t';
  if(val<2)      return 'snow-low';
  if(val<5)      return 'snow-mid';
  if(val<10)     return 'snow-high';
  return 'snow-huge';
}

function showOverlay(msg){ document.getElementById('overlayMsg').textContent=msg; document.getElementById('overlay').style.display='flex'; }
function hideOverlay(){ document.getElementById('overlay').style.display='none'; }

function clearManual(){
  state.data['manual']={ runTime:null, periods:Array(state.numPeriods).fill(null) };
  for(let p=0;p<state.numPeriods;p++){
    const el=document.getElementById(`manual-p${p}`);
    if(el){ el.textContent='—'; el.className='snow-null'; }
  }
  const tot=document.getElementById('manual-total');
  if(tot){ tot.textContent='—'; tot.className='td-total snow-null'; }
}

function exportCSV(){
  if(!state.startDate){ alert('No data loaded yet.'); return; }
  const numP = state.numPeriods;
  const hdrs = ['Source','Run Init'];
  for(let p=0;p<numP;p++) hdrs.push(new Date(state.startDate.getTime()+p*6*3600000).toISOString().slice(0,13)+'z');
  hdrs.push('Storm Total');

  const allSrcs = [...SOURCES, {id:'manual',label:'Manual Entry'}];
  const rows = [hdrs, ...allSrcs.map(src=>{
    const d = state.data[src.id];
    const row=[src.label, d?(d.runTime||''):''];
    let total=0, hasData=false;
    for(let p=0;p<numP;p++){
      const v=d?d.periods[p]:null;
      row.push(v===null?'':v<=0.01?'T':v.toFixed(1));
      if(v!==null){ total+=v; hasData=true; }
    }
    row.push(hasData?total.toFixed(1):'');
    return row;
  })];

  const csv = rows.map(r=>r.map(c=>`"${String(c).replace(/"/g,'""')}"`).join(',')).join('\n');
  const a   = Object.assign(document.createElement('a'),{
    href: URL.createObjectURL(new Blob([csv],{type:'text/csv'})),
    download: `KPHL_snow_${state.startDate.toISOString().slice(0,10)}.csv`
  });
  a.click();
}
</script>
</body>
</html>
